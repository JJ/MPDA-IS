---
nav_order: 14
---

# 4º Nivel: Comienzo de integración continua

## Descripción

En desarrollo ágil se trata de asegurar la calidad del código en todos sus
aspectos posibles. Como se trata de que el código que se incorpore a la rama
principal cumpla estos estándares de calidad, la única forma de asegurarse es
que se lleven a cabo comprobaciones automáticas desde el sistema de gestión del
trabajo en equipo, el repositorio como GitHub.

## Prerrequisitos

Haber superado al menos los tests [del nivel anterior](3.Automatizar.md). Por
otro lado, parte del equipo puede emprender el trabajo en este nivel más o menos
de forma simultánea.

## Conceptos fundamentales

Como este nivel se va a desarrollar en principio simultáneamente al
[3](3.Automatizar.md), algunos de estos conceptos están también repetidos ahí.

* El concepto de *lenguaje de serialización*, usado para representar en texto
  estructuras de datos. En estos lenguajes se encuentra el XML, usado de forma
  extensiva en el ecosistema Java.
* Es conveniente aprender nociones básicas del lenguaje del *shell*, con el cual
  se pueden escribir programas cortos (denominados *scripts*). La mayor parte de
  los gestores de tareas necesitarán lanzar comandos, y a veces incluir pequeños
  programas de una línea que usen variables, por ejemplo, o secuenciar varias
  órdenes.
* El concepto de *hook*, o programa que se lanza cuando sucede algún evento en
  git. Los *workflows* serán eventos que se lanzarán cuando se actualice en
  GitHub una rama o se haga alguna otra actividad tal como crear un *pull
  request*.


## TL;DR

Antes de empezar a escribir código de forma más extensiva, hay que automatizar
las tareas que comprueben la calidad básica del mismo y el seguimiento de las
buenas prácticas habituales en el lenguaje de programación. En general, a estas
herramientas se las denomina *linters*; estos suelen estar en muchos casos
integrados con los IDE, pero conviene en todo caso que se ejecuten
automáticamente, porque es imposible garantizar que todo el mundo está siguiendo
las sugerencias de los editores.

Al final de este nivel, todo el código que se incorpore al proyecto estará
probado y seguirá las buenas prácticas del lenguaje elegido.

## Explicación

La mayor parte de los lenguajes tienen, más allá de la sintaxis, una serie de
buenas prácticas a seguir, que abarcan tanto aspectos léxicos (como los
identificadores que se van a usar para las variables), pragmáticos (dónde
van las llaves, cuantos espacios se usan para indentación) como semánticos (se
está usando una estructura correcta o una declaración correcta para un
identificador, por ejemplo).

Por eso, en prácticamente todos los lenguajes existen *linters*, también
llamados analizadores estáticos de código: analizan el mismo y señalan, aparte
de errores de sintaxis (que deberían haber sido capturados por el IDE de todas
formas) construcciones que no sigan las mejores prácticas aceptadas por la
comunidad y que por tanto conduzcan, en general, a posibles errores en el futuro
o en todo caso a mayor esfuerzo cognitivo por parte de las personas que trabajen
en ese código en cualquier momento.

En desarrollo ágil la principal preocupación es por la calidad, y estos
analizadores de código se aseguran de que, efectivamente, y a nivel simplemente
de lenguaje, esto se cumpla. Pero precisamente por eso se deben ejecutar
automáticamente, y se hace así en un contexto de integración y despliegue
continuo. Por eso en este nivel aprenderemos a configurar un flujo de trabajo
para llevar a cabo precisamente esta tarea.

### Linter

La mayoría de los linters son o bien programas escritos en el mismo lenguaje que
están "limpiando" o bien parte directamente de la *toolchain* del lenguaje de
programación, que puede tener una orden para hacer este tipo de cosas.

En cualquiera de los casos, es una herramienta que hay que elegir y registrar la
decisión para que lo sepa el resto del proyecto; por eso hay que

1. Entender claramente la función de la herramienta
2. Establecer una serie de criterios que se vayan a usar a la hora de
   elegir. ¿Es mejor que sea una herramienta parte del propio *toolchain*?
   ¿Necesitamos que sea configurable? ¿Necesitamos que la configuración básica
   sea suficientemente funcional? ¿O que sea compatible con el linter integrado
   con el IDE, para que lo que uno corrija no se marque como incorrecto por la
   otra parte?
3. Buscar las herramientas que cumplen esos criterios y que se usan con más
   asiduidad en el momento actual.
4. Elegir una herramienta (y explicar la decisión en función de lo anterior)

Una vez elegida la herramienta, habrá que coordinarse con el equipo que esté
trabajando en [el nivel 3](3.Automatizar.md) para usar el *linter* (como
cualquier otra tarea) desde este gestor de tareas. Esto no es imprescindible
durante el desarrollo, pero sí lo será antes de fusionarse.

> Si se decide crear una sola rama para los niveles 3 y 4, y subramas para cada
> uno de estos niveles, este paso se puede hacer una vez que se fusionen las
> subramas y antes de fusionar en la rama principal.

### Flujos de trabajo para integración continua

## Recursos adicionales

## Lista de comprobación

Preguntas antes de entregar que tienes que hacerte, y copiar en tu PR marcando
todo lo que se aplique:

```markdown
* [ ] ¿Se lanza el linter desde el gestor de tareas instalado anteriormente?
* [ ] ¿Está configurado correctamente para que se lance siempre que cambie
cualquier fichero de código, en cualquier directorio?

```

## Entrega de este nivel del proyecto

Se tendrá que haber actualizado el repositorio que se usara en los objetivos
anteriores y [añadir al fichero de este
objetivo](https://github.com/JJ/MPDA-IS-ed/blob/master/proyectos/nivel-4.md) el
nombre del proyecto, el autor y un enlace al mismo y hacer un **pull request**.

## Superación del nivel

Se superará cuando la GitHub Action que ejecute el *linter* funcione y también
se hayan corregido todos los errores que esta haya podido encontrar.

## A donde ir desde aquí

Tras una breve reunión de análisis del *sprint*, se unirá al resto del equipo en
el [siguiente nivel](5.Tests.md)
